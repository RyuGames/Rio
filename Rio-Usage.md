## Usage Guide

- [Side-by-side Express and Rio](#side-by-side-express-and-rio)
- [Argument Checking](#argument-checking)
- [Argument Optionality](#argument-optionality)
- [Argument Types](#argument-types)
- [Shorthand Arguments](#shorthand-arguments)
- [Setting up a config (.riorc.js)](#setting-up-a-riorcjs)

### Side-by-side Express and Rio

Here is an example Express API endpoint that takes no arguments and returns the string `"Hello, world"`:

The key differences are:
- Initializing rio with the express application
- Changing `app` to `rio`
- Adding an empty array for the expected arguments, after the callback
- Adding an optional description string, after the arguments array
- Adding an optional response example


<table>    
  <tr>    
    <th>Original</th>    
    <th>Updated</th>    
  </tr>    
  <tr>    
    <td>    
      <pre>    
            const express = require('express');
            <br>
            const app = express();
            <br>
            app.get('/', (req, res) => {  
              res.status(200).send('Hello, world');  
            });
      </pre>    
    </td>    
    <td>    
      <pre>    
            const express = require('express');
            const rio = require('rio-express');
            <br>
            const app = express();
            rio.init(app);
            <br>
            app.get('/', (req, res) => {  
              res.status(200).send('Hello, world');  
            },
            [],
            'Returns the string \'Hello, world\'',
            'Hello, world');  
      </pre>    
    </td>    
  </tr>    
</table>

### Argument checking
Here is an implementation of an API used to sum two integer values:

```javascript
const rio = require('rio-express');

const app = express();
rio.init(app);

const A = rio.RequiredInteger('a', 'A number to be added');
const B = rio.RequiredInteger('b', 'Another number to be added');

rio.get(app, '/sum', (req, res) => {
  let { a, b } = req.query;
  a = parseInt(a, 10);
  b = parseInt(b, 10);
  const result = JSON.stringify({ result: a + b });
  res.status(200).send(result);
},
[
  A,
  B,
],
'Adds two numbers together',
{ result: 2 });
```

Initialize arguments with:
- The expected name of the variable
- An optional description

They are then passed into the `rio.get` or `rio.post` functions. If the request to the endpoint is missing either an integer value for `a` or `b`, then the endpoint will automatically return an error 403, without calling the callback.

### Argument Optionality
Initializers begin with the word `'Required'` or `'Optional'` and are followed by the type.

### Argument Types
Rio currently supports the following types:
- String (`RequiredString` or `OptionalString`)
- Integer (`RequiredInteger` or `OptionalInteger`)
- Float (`RequiredFloat` or `OptionalFloat`)
- Boolean (`RequiredBoolean` or `OptionalBoolean`)
- Array (`RequiredArray` or `OptionalArray`)
- Map (`RequiredMap` or `OptionalMap`)

### Shorthand Arguments
Each initializer can also be shorted to begin with the letters `'r'` or `'o'` instead of the full words, followed by the types.

For example:
- `rStr` and `oStr`
- `rInt` and `oInt`
- `rFloat` and `oFloat`
- `rBool` and `oBool`
- `rArray` and `oArray`
- `rMap` and `oMap`

Example Usage of shorthand initializers:
```javascript
const rio = require('rio-express');

const app = express();
rio.init(app);

rio.get(app, '/sum', (req, res) => {
  let { a, b } = req.query;
  a = parseInt(a, 10);
  b = parseInt(b, 10);
  const result = JSON.stringify({ result: a + b });
  res.status(200).send(result);
},
[
  rio.rInt('a', 'A number to be added'),
  rio.rInt('b', 'Another number to be added'),
],
'Adds two numbers together');
```

### Setting up a .riorc.js
The `.riorc.js` file should be in the following format:
```javascript
module.exports = {
  modules: {
    account: 'The account module description',
    payments: 'The payments module description',
  },
};
```

Where the `modules` field includes descriptions for each module.

The API documentation generator can parse endpoints into modules automatically.

For example, if your endpoints were the following:
```bash
/account/create
/account/delete
/account/get
/account/update
/payments/create
/payments/delete
/payments/get
/payments/update
```

The modules `/account` and `/payments` would be automatically detected and have their own documentation created. This would create the following documentation: 
- `AUTOGENERATED-API.README.md` (Outlines the modules)
    - `API-Modules/account-API.md` (Account module)
    - `API-Modules/payments-API.md` (Payments module)

The module level documentation will load the descriptions out of the `.riorc.js`. 
